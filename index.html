<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Development Environments as Code</title>
    <link rel="shortcut icon" href="./favicon.ico" />
    <link rel="stylesheet" href="./dist/reset.css" />
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./assets/./theme/swiss.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/intellij-light.css" />


  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template">

# Development Environments as Code <!-- .element: id="title" -->

<!-- {{{ -->

<hr> 

<div class=two-col>
<div class=left style=width:40% >

Johannes H√ºttinger

<br>


</div>
<div class=right style=white-space:nowrap >

[<i class="fa-solid fa-envelope"></i> johannes.huettinger@aformatik.de](mailto:johannes.huettinger@aformatik.de)

[<i class="fa-solid fa-house"></i> aformatik &ndash; Training & Consulting](https://www.aformatik.de)\
[<i style=visibility:hidden class="fa-solid fa-house"></i> www.aformatik.de](https://www.aformatik.de)

</div>
</div>

<!-- <iframe src="?controls=false#/1/0/4"  width=800px height=800px style="position:absolute; top:50%; left:50%; border: 1px solid black; transform: scale(1); transform-origin: 0 0" /> -->

<aside class="notes"><ul>
<li><p>Jeder Entwickler kennt das Problem:</p>
<ul>
<li>Softwareprojekt = Entwicklungsumgebung einrichten<ul>
<li>System, IDE, Compiler, Docker, DBs, ...</li>
</ul>
</li>
<li>Dazu kommen Systemwartung, Verteilung im Team, ...</li>
<li>Dieser Talk:<ul>
<li>wie m√∂glichst reibungslos und automatisiert</li>
<li>f√ºr Entwickler hei√üt das: mit Code</li>
</ul>
</li>
</ul>
</li>
<li><p>Warum ist das √ºberhaupt relevant?</p>
<ul>
<li>Zu jedem Softwareprojekt geh√∂rt eine EU</li>
</ul>
</li>
<li><p>F√ºr</p>
<ol>
<li>Individualsoftware: <ul>
<li>Mehrere Projekte, Je nach Projektsituation wechseln Entwickler zwischen Projekten</li>
</ul>
</li>
<li>Produktentwicklung: Viele Entwickler ben√∂tigen genau die gleiche EU</li>
<li>Open Source Projekte:<ul>
<li>neue Contributor sollen m√∂glichst schnell anfangen k√∂nnen</li>
<li>nicht lange mit Setup besch√§ftigen</li>
</ul>
</li>
</ol>
</li>
</ul>
<!-- }}} --></aside></script></section><section ><section data-markdown><script type="text/template">
## Wozu Entwicklungs&shy;umgebungen?

<!-- {{{ -->

<div class="two-col">
<div class="left fragment">

### 1.&nbsp;&nbsp;Wartung
<!-- .element: style="margin-bottom: 1em; margin-top: 1em" -->

#### Tools zur Entwicklung eines Projektes bereitstellen

#Erstellung #Updates #Rollbacks #Automatisierung #Reproduzierbarkeit 

</div>
<div class="right fragment">

### 2.&nbsp;&nbsp;Developer Experience
<!-- .element: style="margin-bottom: 1em; margin-top: 1em" -->

#### Entwickler entwickeln lassen

#Integration #Performance #Individualisierung

</div>
</div>

<aside class="notes"><ul>
<li>Wozu braucht man EUs?</li>
</ul>
<ol>
<li><p>Tools bereitstellen (offensichtlich)</p>
<ul>
<li>dazu geh√∂rt aber auch: <ul>
<li>Projekt entwickelt sich =&gt; √Ñnderungen (Wartung)</li>
<li>Verteilung im Team<ul>
<li>Automatisierung / Zuverl√§ssigkeit</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Entwicklerprod. (DX)</p>
<ul>
<li>EU soll mich m√∂glichst produktiv machen</li>
<li>=&gt; Performance</li>
<li>=&gt; Integration mit Umgebungs√ºbergreifenden Tools (Teams, Mail, etc.)</li>
<li>=&gt; Individualisierung</li>
</ul>
</li>
</ol>
<ul>
<li>Wir schauen uns in diesem Vortrag diese beiden Aspekte an, d.h. im Hinterkopf behalten</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## Entwicklung einer Entwicklungsumgebung

<img class="embed" src="./imgs/devenv-flow.drawio.svg" style="margin-left:5em"/>

<aside class="notes"><ul>
<li><p>haben festgestellt, das EU nicht etwas statisches ist, sondern sich mit Projekt mitentwickelt</p>
</li>
<li><p>Entwicklung eines Projektes in Versionsverwaltung (Git) festgehalten</p>
</li>
<li><p>z.B. Anfang: JDK8, eclipse</p>
</li>
<li><p>nach einigen Jahren: JDK17, IJ, nodejs</p>
</li>
<li><p>Weihnachten 2021: log4j =&gt; Fixes backporten</p>
<ul>
<li>komplette Historie des Codes in Git =&gt; git checkout v1</li>
<li>EU von vor ein paar Jahren n√∂tig</li>
</ul>
</li>
<li><p>genauso auch EU: an jedem Commit d. Projekts passende Tools zur Verf√ºgung</p>
</li>
<li><p>Oder Feature branches</p>
</li>
<li><p>Zus√§tzlich zu Projektentwicklung: Entwickler</p>
<ul>
<li>ver√§ndern den Zustand der EU: <ul>
<li>Konfiguration, Paketinstallation (DX)</li>
<li>Zustand (DB, Logins, ...)</li>
</ul>
</li>
<li>diese √Ñnderungen mitnehmen zwischen Versionen</li>
</ul>
</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## Stand der Dinge

<div class="two-col">
<div class="left">

- ~~‚ùì Manuell / Bare Metal~~ <!-- .element: class="fragment""-->
- üüß Virtuelle Maschinen
<!-- .element: class="fragment""-->
- üü© ‚ö†Ô∏è VS Code + Docker<br>(Devcontainers / Codespaces)
<!-- .element: class="fragment""-->
- üü© Vagrant + Ansible
<!-- .element: class="fragment""-->
- ...
<!-- .element: class="fragment""-->

<!-- .element: style="list-style: none"-->

</div>
<div class="right fragment" style="width:50%">
<img class="embed" src="./imgs/devenv-flow-trad.drawio.svg" />
</div>
</div>

<aside class="notes"><ul>
<li><p>Das war die Theorie. Wie siehts in der Praxis aus?</p>
</li>
<li><p>Schauen wir uns mal die g√§ngigen Vorgehensweisen an</p>
<ul>
<li>H√§ufig: Manuell auf Bare Metal<ul>
<li>keine L√∂sung, weil nicht automatisch oder reproduzierbar</li>
</ul>
</li>
<li>Besser: manuelle Installation (einmalig) in VM<ul>
<li>dann VM verteilen =&gt; Kollegen starten einfach nur VM</li>
</ul>
</li>
<li>Seit einigen Jahren Infrastructure as Code<ul>
<li>Docker, Vagrant, Ansible</li>
<li>d.h. Systemconf. als Code (Skripte)</li>
<li>Tool, das diese Skripte realisiert</li>
<li>Code: kann in Projekt Repo liegen und sich mitentwickeln</li>
</ul>
</li>
</ul>
</li>
<li><p>Werden diese Ans√§tze unseren Anforderungen gerecht? NEIN</p>
<ul>
<li>Warum nicht? <ul>
<li>inkrementelle Updates der EU nicht m√∂glich, sobald EU ver√§ndert wurde</li>
<li>virtuelle Maschinen sowieso<ul>
<li>hier muss jede Version manuell erstellt werden</li>
</ul>
</li>
<li>Tools erstellen immer gew√ºnschte Version from Scratch</li>
<li>Zustand, Anpassungen gehen dazwischen verloren</li>
<li>Deshalb: selten Updates, und dann manuell einrichten oder manuell updaten</li>
</ul>
</li>
<li>Au√üerdem<ul>
<li>VMs:<ul>
<li>erstellung oft nicht dokumentiert</li>
<li>nach einigen Jahren: Wie hab ich das damals gemacht?</li>
</ul>
</li>
<li>Scripte:<ul>
<li>nicht ergonomisch um komplexe Systeme zu konfigurieren</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Warum ist inkrementelles Updaten / rollbacks nicht so einfach m√∂glich?</p>
</li>
<li><p>Um das zu verstehen, schauen wir uns an, wie diese Ans√§tze ein System einrichten</p>
</li>
</ul>
<!-- }}} --></aside></script></section></section><section ><section data-markdown><script type="text/template">
## Traditionelles Systemmanagement

<!-- {{{ -->

<div class="two-col">
<div class=left style=width:60% >

```text
apt update && apt upgrade
apt install x y z

useradd bob
groupadd postgres
chown -R bob /var/lib/...
vi /etc/ssh/sshd_config
systemd enable sshd.service
```
<!-- .element: style="font-size:1em" -->

<br>

- Destruktive Inplace-Updates
- Ver√§nderung des globalen Systemzustands
- Nicht-atomar
- üëâ &nbsp;Zustandsabh√§ngig
<!-- .element: style="list-style:none;font-weight:bolder;transform:translate(-1.5em,0)" -->

<!-- .element: class="fragment" -->

</div>
<div class=right style=width:35% >

```text
‚îú‚îÄ‚îÄ etc
‚îÇ  ‚îî‚îÄ‚îÄ systemd
‚îú‚îÄ‚îÄ home
‚îú‚îÄ‚îÄ usr
‚îÇ  ‚îú‚îÄ‚îÄ bin
‚îÇ  ‚îú‚îÄ‚îÄ lib
‚îÇ  ‚îî‚îÄ‚îÄ share
‚îî‚îÄ‚îÄ var/lib
```
 <!-- .element: style="font-size:1em" -->

<br>

- "Dependency Hell"
- Oft nur *eine* Version einer Software
- Keine unpriviligierte Installation

<!-- .element: class="fragment" -->

</div>
</div>


<aside class="notes"><ul>
<li>Ans√§tze basieren alle auf traditionellen System- / Paketmanagement</li>
<li>Auf der rechten Seite ein Linux Dateisystem<ul>
<li>vordefinierte Order, <ul>
<li>etc = configs</li>
<li>home = Userdateien</li>
<li>/usr/bin = Programme</li>
<li>/usr/lib = Libs</li>
</ul>
</li>
<li>auf Win / Mac √§hnlich, nur andere Namen</li>
</ul>
</li>
<li>links ein ausschnitt aus meinem Dockerfile / Ansible Playbook<ul>
<li>reihe von Befehlen</li>
<li>Jeder Befehl ver√§ndert den Systemzustand destruktiv und inplace 
  =&gt; nicht mehr r√ºckg√§ngig</li>
<li>Das ganze ist nicht atomar
  =&gt; Skript schl√§gt in der Mitte fehl 
  =&gt; undef. Zustand. wei√ü nicht, was ver√§ndert wurde</li>
<li>Befehle ver√§ndern nicht nur den Zustand, sondern h√§ngen auch davon ab</li>
<li>Reihenfolge beachten =&gt; Fragil</li>
</ul>
</li>
<li>Daraus wird klar:<ul>
<li>ich kann zwar so &quot;from scratch&quot; mein System konfigurieren</li>
<li>aber nach der Installation ver√§ndert jeder Entwickler seinen Systemzustand</li>
<li>von einem unbekannten Systemzustand kein zuverl√§ssiges Updaten m√∂glich</li>
<li>deshalb immer from scratch</li>
</ul>
</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## Imperativ vs. Funktional

<div class="two-col">
<div class=left >

```java
static int x;

int add(int a, int b) {
    ...
    Date.now()
    ...
    new Random()
    ...
    x++
    ...
}
```
<!-- .element: class="fragment" style="font-size:1em" -->

<br>

- **Mutable** by default
- Uneingeschr√§nkte Seiteneffekte

<!-- .element: class="fragment" -->

</div>
<div class=right>

```haskell
plus :: Int -> Int -> Int
plus = ...










```
<!-- .element: class="fragment" style="font-size:1em" -->

<br>

- **Immutable** by default
- Referentielle Transparenz

<!-- .element: class="fragment" -->

</div>
</div>

<aside class="notes"><ul>
<li>√Ñhnliches Problem auch in Programmierung</li>
<li>Meiste Sprachen<ul>
<li>imperativ =&gt; Reihe von Befehlen<ul>
<li>wie bei trad. Systemmanagement</li>
</ul>
</li>
<li>Mutability by default</li>
<li>Seiteneffekte: Abh√§ngig von Umgebung und ver√§ndern Umgebung</li>
<li>wei√ü nicht, von was eine Codezeile abh√§ngt und was sie tut<ul>
<li>=&gt; muss reinschauen</li>
</ul>
</li>
</ul>
</li>
<li>Dagegen Rein Funktionale Sprachen:<ul>
<li>Immutable, keine versteckten Seiteneffekte</li>
<li>referentielle Transparenz =&gt; bei gleichen Parametern liefern Funktionen immer gleichen Wert</li>
<li>=&gt; reproduzierbar</li>
<li>Funktionalit√§t meist aus Typsignatur (+Name) ersichtlich</li>
</ul>
</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## Funktionales Paketmanagement

<img class="embed" src="./imgs/derivation.drawio.svg" />

<aside class="notes"><ul>
<li>Zur√ºck zum Systemmanagement: </li>
<li>hier ist unser imperatives Management:<ul>
<li>Systemzustand += Source Code + Buildscript</li>
<li>Paket bauen / installieren =&gt; Systemzustand nehmen und ver√§ndern</li>
</ul>
</li>
<li>Wie kann funktionales Prinzip √ºbertragen werden?<ul>
<li>Alle Seiteneffekte verbieten, Abh√§ngigkeiten explizit machen</li>
<li>Z.B. Java Binary: JDK, Maven, JRE</li>
<li>R√ºckgabewert:<ul>
<li>ver√§ndere nicht mehr System mit gebauten Dateien</li>
<li>sondern speichere Dateien separat ab</li>
</ul>
</li>
</ul>
</li>
<li>Somit mein Paket bitgenau reproduzierbar - bei exakt gleichen Inputs exakt gleicher Output <ul>
<li>=&gt; Referentielle Transparenz</li>
</ul>
</li>
<li>Wie stelle ich bitgenau √Ñquivalenz von Paketen fest? <ul>
<li>Checksum bilden</li>
<li>Da Paket nur noch von Inputs abh√§ngt, kann dessen CS nur anhand der von Inps. berechnet werden</li>
</ul>
</li>
<li>Das ganze wird rekursiv durchs ganze System durchgezogen werden</li>
<li>=&gt; jedes einzelne Bit meines Systems kontrolliert</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
# Nix <!-- .element: class="nix-header" --> [![GitHub stars](https://img.shields.io/github/stars/nixos/nixpkgs?color=%231365FF&style=social)](https://GitHub.com/nixos/nixpkgs/stargazers/)

> Nix is a purely functional package manager and deployment system for POSIX
<!-- .element: style="width:100%" -->

<div class=figure>

![Repo stats](./imgs/map_repo_size_fresh.svg) <!-- .element class="repology" -->

<figcaption style=margin-right:20%>Quelle: Repology</figcaption>
</div>

<!-- {{{ -->
<style>
.nix-header::before {
    content: "";
    display: inline-block;
    background-image: url(./imgs/nixos.svg);
    background-size: contain;
    background-repeat: no-repeat;
    height: 1em;
    width: 1em;
    margin-bottom: -.2em;
    margin-right: .2em;
}
.nix-header { width: 87%; }
.nix-header a {
    float: right;
}
.nix-header img {
    width: 1.5em;
}
.repology {
    width: 70%;
    margin-left: 15% !important;
}
</style>
<!-- }}} -->

<aside class="notes"><ul>
<li>Hab ich nat√ºrlich nicht selber erfunden</li>
<li>dieses Konzept implementiert der Paketmanager <em>Nix</em></li>
<li>in der Beschreibung steckt das rein funktionale / referentielle Transparenz</li>
<li>Paar Eckdaten:<ul>
<li>etwa 20 Jahre alt</li>
<li>Haupts√§chlich Linux und MacOS</li>
<li>Im vergleich zu anderen PMs: sehr umfangreich: etwa 80k Packages</li>
</ul>
</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## Nix Store <!-- .element: class="nix-header" --> 

<div class=two-col>
<div class=left >
<img data-fragment-index=1 class=fragment style="width:100%;background:none" src="./imgs/nix-store.drawio.svg" />
</div>
<div class=right>

<img data-fragment-index=0 class=fragment src="./imgs/derivation.drawio.svg" style="width:15em;position:absolute;border:1px solid black!important;border-radius:.5em;top:-1em;background:white;padding:1em" />

- ‚úÖ Immutable / Append-only Store
- ‚úÖ ~~Dependency Hell~~
- ‚úÖ Mehrere Versionen
- ‚úÖ Multi User Installations

<!-- .element class="fragment" style="list-style: none; margin-top:8em; white-space: nowrap" -->

</div>
</div>

```bash
$ /nix/store/12c9a5ced0...hello-world/bin/hello-world
Hello World!
```
<!-- .element: class="fragment" style="font-size:1em" -->

<!-- {{{
```
/nix/store
‚îú‚îÄ‚îÄ aa82aeb2d6...jdk17
‚îÇ   ‚îî‚îÄ‚îÄ bin
‚îÇ       ‚îî‚îÄ‚îÄ javac
‚îú‚îÄ‚îÄ c3e8d7680c...jre17
‚îÇ   ‚îî‚îÄ‚îÄ bin
‚îÇ       ‚îî‚îÄ‚îÄ java
‚îú‚îÄ‚îÄ 12c9a5ced0...hello-world
‚îÇ   ‚îú‚îÄ‚îÄ bin
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ hello-world-java
‚îÇ   ‚îî‚îÄ‚îÄ lib
‚îÇ       ‚îî‚îÄ‚îÄ HelloWorld.class
‚îî‚îÄ‚îÄ 9cc608415e...glibc2.37
    ‚îî‚îÄ‚îÄ lib
        ‚îî‚îÄ‚îÄ libc.so
```
}}} -->

<aside class="notes"><ul>
<li><p>Zur√ºck zum Paketmanagement</p>
</li>
<li><p>Wie sieht diese hashgenaue verlinkung von Inputs aus?</p>
</li>
<li><p>Nix: globalen, append-only Store in /nix/store</p>
</li>
<li><p>alle gebauten <strong>DERIVATIONS</strong> mit Hash und Name in einem globalen Ordner</p>
</li>
<li><p>Derivations verweisen direkt auf ihre Inputs</p>
</li>
<li><p>Z.B. hello-world auf JRE (runtime deps), JRE und JDK auf GNU LibC</p>
</li>
<li><p>Store Paths k√∂nnen nicht ver√§ndert, nur hinzugef√ºgt werden (immutability)</p>
</li>
<li><p>Nebenbei: beliebig viele Versionen, unpriv. Install</p>
</li>
<li><p>Damit haben wir ein funktionierendes Paketsystem!</p>
</li>
<li><p>nicht sehr ergonomisch</p>
</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## NixOS <!-- .element: class="nix-header" -->

<div class=two-col>
<div class=left style=width:65% >
<img class=fragment style="width:100%;background:none" src="./imgs/nixos-store.drawio.svg" />
</div>
<div class=right style=width:35% >

- Systemkonfigurationen als Nix-Derivations
- Atomare Updates und Rollbacks
- Granulare Kontrolle des Systemzustands
- Build-Targets: Bare Metal, ISOs, VM-Images, Docker-Images, ...

<!-- .element class="animated" -->

</div>
</div>

```bash
$ hello-world
Hello World!
```
<!-- .element: class="fragment" style="font-size:1em" -->

<!-- {{{
```
‚îú‚îÄ‚îÄ /etc
‚îÇ   ‚îî‚îÄ‚îÄ profile
‚îú‚îÄ‚îÄ /home
‚îî‚îÄ‚îÄ /nix
    ‚îú‚îÄ‚îÄ var/nix/profiles
    ‚îÇ   ‚îî‚îÄ‚îÄ system
    ‚îî‚îÄ‚îÄ store
        ‚îú‚îÄ‚îÄ 12c9a5ced0...hello-world-v1
        ‚îú‚îÄ‚îÄ 52kaj3kf9e...system-1
        ‚îú‚îÄ‚îÄ a7g8k2lf9o...hello-world-v2
        ‚îî‚îÄ‚îÄ bfeaj8415e...system-2
            ‚îú‚îÄ‚îÄ /bin/hello-world
            ‚îî‚îÄ‚îÄ /etc/profile

export PATH="/nix/store/12c9a5ced0...hello-world/bin:..."
```
}}}-->

<aside class="notes"><ul>
<li>NixOS nutzt das um ein komplettes Betriebssystem zu bauen</li>
<li>System wird als Nix-Derivation gebaut<ul>
<li>dazu geh√∂ren Konfigdateien (Text), </li>
<li>z.B. /etc/profile, in der meine Shell initialisiert wird</li>
<li>hier PATH setzen, d.h. hello-world ohne expliziten Pfad aufrufen</li>
</ul>
</li>
<li>diese Dateien liegen jetzt im Store</li>
<li>tats√§chliche Dateien, die von Programmen genutzt werden, verweisen in den Store</li>
<li>Das ganze geht √ºber einen festen Zwischenlink, der atomar ausgetauscht werden kann<ul>
<li>d.h. bei Update baue ich neues System im Store</li>
<li>danach wird der zwischenlink atomar ausgetauscht</li>
<li>alle Systemdateien gehen da durch und werden somit gleichzeitig getauscht</li>
<li>geht nat√ºrlich auch zur√ºck =&gt; rollbacks</li>
</ul>
</li>
<li>Granular:<ul>
<li>Nur Systemdateien werden von NixOS ver√§ndert</li>
<li>User-Daten wie /home werden von NixOS nicht ver√§ndert</li>
</ul>
</li>
<li>Damit ist unser urspr√ºngliches Problem der Updates gel√∂st<ul>
<li>Systemzustand wird nicht angefasst und kann √ºber Updates mitgenommen werden</li>
</ul>
</li>
<li>F√ºr prod. Nutzung dieses Systems fehlt noch hardwareanbindung<ul>
<li>da system selbst eine Derivation, kann darauf aufbauend f√ºr verschiedene Targets gebaut werden<ul>
<li>Bare Metal: Bootloader, Festplattenpartionierung</li>
<li>ISOs Image</li>
<li>VM- und Docker-Images</li>
</ul>
</li>
<li>=&gt; Treiber, dazu sp√§ter mehr, erst schauen wir uns an, wie NixOS konfiguriert wird.</li>
</ul>
</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## Systemkonfiguration mit NixOS <!-- .element: class="nix-header" -->

[<i class="fa-brands fa-github"></i> github.com/htngr/jfs-23-deac/configuration.nix](https://github.com/htngr/jfs-23-deac/blob/master/configuration.nix)

[<i class="fa-solid fa-magnifying-glass"></i> NixOS Search (Packages/Options)](https://search.nixos.org/packages)


<!-- }}} -->
</script></section></section><section ><section data-markdown><script type="text/template">
## NixOS - Driver <!-- .element: class="nix-header" --> 

<!-- {{{ -->

[<i class="fa-brands fa-github"></i> github.com/NixOS/nixpkgs/nixos/modules/virtualisation](https://github.com/NixOS/nixpkgs/tree/master/nixos/modules/virtualisation)
<!-- .element: style="margin-top:-2em" -->


```nix
# configuration.nix
{ pkgs, modulesPath, ... }: {

  imports = [ 
    # VMware derivation: config.system.build.vmwareImage
    "${modulesPath}/virtualisation/vmware-image.nix" 

    # docker **container** derivation: config.system.build.tarball
    "${modulesPath}/virtualisation/docker-image.nix" 
  ];

  ...
}
```
<!-- .element: style="font-size:.7em" -->

<aside class="notes"><ul>
<li>Um das ganze praktisch zu nutzen, m√ºssen wir noch einen Hardware-Treiber hinzuf√ºgen</li>
<li>diese NixOS-Module bauen aus der Systemderivation eine Derivation mit einem ISO image</li>
<li>oder hier: ein VMware Image</li>
<li>Damit: k√∂nnten wir Feierabend machen, da wir unsere Anforderungen was
inkrementelle Updates usw. angeht erf√ºllt haben</li>
<li>ABER: 2. Anforderung: Entwicklererfahrung / Performance</li>
<li>VMs: <ul>
<li>nicht unbedingt Resourceneffizient, performant (Input lag)</li>
<li>stark isoliert vom Host (Dateien, Grafik / Fenster)</li>
</ul>
</li>
<li>besser: Container, unter Linux: Docker / Podman f√ºr NixOS<ul>
<li>leichtgewichtiger, weniger Resourcen</li>
<li>weniger isoliert, einfacher Dateien u. Grafik usw. teilen<ul>
<li>bind mounts</li>
<li>X-Socket passthrough =&gt; nativ wirkende Fenster aus Container</li>
</ul>
</li>
</ul>
</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## Windows Subsystem for Linux <!-- .element: class="wsl-header" -->

<img class="embed" style="width:90%;height:100%;" src="./imgs/wsl.drawio.svg" />

<!-- {{{ https://bendyworks.com/assets/images/blog/2020-05-21-setup-windows-development-eb5c79a7.png -->
<style>
.wsl-header::before {
    content: "";
    display: inline-block;
    background-image: url(./imgs/wsl-2-logo.png);
    background-size: contain;
    background-repeat: no-repeat;
    height: 1.5em;
    width: 1.5em;
    margin-bottom: -.4em;
    margin-right: .3em;
}
</style>
<!-- }}} -->

<aside class="notes"><ul>
<li>unter windows: WSL2</li>
<li>nicht genauer auf details<ul>
<li>Talk Sp√§ter: &quot;Wsl2 der warp antrieb f√ºr Windows-Entwickler&quot; von Mirko Pleli</li>
</ul>
</li>
<li>Von Microsoft, ab Win 10</li>
<li>Linux in Windows nutzen<ul>
<li>Ressourceneffizient, √§hnlich wie Container</li>
<li>Linux Programme genauso schnell wie Windows Anwendungen ausf√ºhren</li>
</ul>
</li>
<li>Dateisystem, Grafik, Netzwerk wird geteilt</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## NixOS-WSL <!-- .element: class="wsl-header" -->

[<i class="fa-brands fa-github"></i> github.com/htngr/jfs-23-deac/wsl.nix](https://github.com/htngr/jfs-23-deac/blob/master/wsl.nix)

[<i class="fa-solid fa-puzzle-piece"></i> NixOS-WSL](https://github.com/nix-community/NixOS-WSL)


<!-- }}} -->
</script></section></section><section ><section data-markdown><script type="text/template">
<!-- {{{ -->

## codchi &ndash; <span style="color:#003CAC">Cod</span>e Ma<span style="color:#003CAC">chi</span>nes
<!-- .element: class="devenv-header fragment" data-fragment-index="1" -->
[<i class="fa-solid fa-house"></i> codchi.dev](https://codchi.dev) 
[<i class="fa-brands fa-github"></i> github.com/aformatik/codchi](https://github.com/aformatik/codchi) <!-- .element: style="margin-left:.5rem" -->
<!-- .element: style="margin-top:-2em;margin-bottom:1em" class="fragment" data-fragment-index="1" -->


<div class=fragment style="width:100%" data-fragment-index="0">
<img class="embed fragment" style="width:90%;height:100%;" src="./imgs/nixos-devenv.drawio.svg" />
</div>

<style>
.devenv-header::before {
    content: "";
    display: inline-block;
    background-image: url(./imgs/logo.png);
    background-size: contain;
    background-repeat: no-repeat;
    height: 1em;
    width: 1em;
    margin-bottom: -.1em;
    margin-right: .2em;
}
</style>

<aside class="notes"><ul>
<li>Wir sehen<ul>
<li>NixOS + Container erf√ºllt schon ziemlich gut unsere Anforderungen bzgl. Wartung und DX</li>
<li>Aber: man kann noch einiges verbessern</li>
</ul>
</li>
<li>Wir bei aformatik haben das ausprobiert. Ergebnis: Open source tool &quot;codchi&quot; (Github)</li>
<li>Probleme: <ul>
<li>Man kann nicht einfach seine EU als NixOS Modul konfigurieren<ul>
<li>je nach OS muss nach NixOS-Treibern und passenden Tools gesucht werden</li>
<li>codchi: optimierte NixOS Treiber f√ºr Windows, Linux und Mac (comming soon)</li>
</ul>
</li>
<li>EU bleiben relativ schwergewichtig weil Nix-Store drin verpackt<ul>
<li>5 EUs mit 70% √úberschneidung =&gt; 5x auf der Festplatte</li>
<li>Store ist immutable =&gt; einfach Store teilen!</li>
<li>EU ohne Store: wenige MBs</li>
<li>=&gt; inkrementelles Bauen</li>
</ul>
</li>
<li>speziell Windows:<ul>
<li>performantere Grafikl√∂sung: eigener X-Server &amp; Sound Server</li>
<li>Shortcuts</li>
</ul>
</li>
<li>Crossplatform CLI =&gt; gleiches Interface auf allen Platformen (Linux &amp; MacOS comming soon)</li>
</ul>
</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## codchi auf Windows <!-- .element: class="devenv-header" -->

[<i class="fa-brands fa-github"></i> github.com/aformatik/codchi/README.md](https://github.com/aformatik/codchi#installation)

<!-- }}} -->
</script></section></section><section ><section data-markdown><script type="text/template">
## DEaC mit NixOS - Fazit

<!-- {{{ -->

- ‚úÖ Deklarative Systemkonfiguration statt Scripting
- ‚úÖ Entwicklungsumgebung entwickelt sich mit Projekt
- ‚úÖ Automatisierte und Reproduzierbare Installation, Updates und Rollbacks
- ‚úÖ Individualisierbare Entwicklungsumgebungen
- ‚úÖ Gute Developer-Experience m√∂glich &ndash; Tools wie *codchi* helfen

<!-- .element: class="animated" style="list-style:none" -->

<br>

- ‚ùì Anderes Konzept von Systemmanagement
- ‚ùì Lernkurve
- ‚ùì (noch) wenig Dokumentation

<!-- .element: class="animated" style="list-style:none" -->

<aside class="notes"><ul>
<li><p>Das wars auch schon</p>
</li>
<li><p>Wir haben uns heute angeschaut:</p>
<ul>
<li>wie funktioniert eine optimale EU?</li>
<li>warum sind bestehende Ans√§tze suboptimal =&gt; imperativ</li>
<li>wie k√∂nnen wirs besser machen? =&gt; NixOS</li>
</ul>
</li>
<li><p>mit NixOS</p>
<ul>
<li>deklarative Programmierung des Systems statt imperative, fragile Skripte</li>
<li>EU liegt als Code vor, EU kann an jedem Commit ausgecheckt werden</li>
<li>Installation / Updates / Rollbacks sind automatisiert und reproduzierbar (bit-genau)</li>
<li>durch NixOS-Module sogar EU-√ºbergreifend individualisierbar</li>
<li>Gute DX m√∂glich durch das richtige Tooling</li>
</ul>
</li>
</ul>
<!-- }}} --></aside></script></section><section data-markdown><script type="text/template">
# Development Environments as Code <!-- .element: id="title" -->

<!-- {{{ -->

<hr> 

<div class=two-col>
<div class=left style=width:40% >

Johannes H√ºttinger

<br>


</div>
<div class=right style=white-space:nowrap >

[<i class="fa-solid fa-envelope"></i> johannes.huettinger@aformatik.de](mailto:johannes.huettinger@aformatik.de)

[<i class="fa-solid fa-house"></i> aformatik &ndash; Training & Consulting](https://www.aformatik.de)\
[<i style=visibility:hidden class="fa-solid fa-house"></i> www.aformatik.de](https://www.aformatik.de)

<br>

[<i class="fa-regular fa-snowflake"></i> nixos.org](https://nixos.org)

[codchi.dev](https://codchi.dev) <!-- .element class="devenv-header" -->

</div>
</div>


<!-- }}} -->

</script></section></section></div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        slideNumber: true,
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"transition":"slide","fragments":true}, queryOptions);
    </script>

    <script src="./assets/lib/mermaid.min.js"></script>
    <script src="./assets/lib/reveal-mermaid.js"></script>
    <script src="./assets/lib/jfs.js"></script>
    <script src="./assets/lib/leader-line.min.js"></script>

    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
